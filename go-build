#!/usr/bin/env bash
# Usage:
#   go-build -o outfile -c compiler [package]
#
####
set -eu
REPO_ROOT=$(cd $(dirname $0);pwd)
verbose=""
if [[ $1 == "-x" ]]; then
  verbose="1"
  shift
fi

tmp=${tmp:=/tmp/bbg}

shift # skip -o
out_file=$1
shift # skip -c
compiler=$2
package=$3

out_file_abs=$(realpath $out_file)
workdir=${tmp}/${out_file##*/}.d
export WORKDIR=$workdir
mkdir -p $workdir
$compiler list -deps $package  > $workdir/list
if [[ -n $verbose ]]; then
  echo '>' $compiler list -deps $package
  cat $workdir/list
fi
PKGS=""
while read p
do
  if [[ $p == "main" ]]; then
    continue
  fi
  PKGS="$PKGS $p"
  p2=$(echo $p | tr '/' '.')
  if [[ -n $verbose ]]; then
    echo '>' $compiler compile -o $workdir/$p2  $p
  fi
  $compiler compile -o $workdir/$p2  $p
done < $workdir/list

# Compile main
  if [[ -n $verbose ]]; then
    echo '>' $compiler compile -o $workdir/main $package
  fi
$compiler compile -o $workdir/main $package

cd $workdir

# Generate __INIT__.s
{
cat <<EOF
.text
# Initializes all packages except for runtime
.global __INIT__.init
__INIT__.init:
EOF

while read p
do
  if [[ $p == "runtime" ]] ; then
      continue
  fi
  p2=$(echo $p | tr '/' '.')
  basename=${p##*/}
  echo "  callq ${basename}.__initVars"
  if grep -E '^func init' ${p2}.dcl.go >/dev/null ; then
    echo "  callq ${basename}.init"
  fi
done < $workdir/list

echo "  ret"
} > __INIT__.s
as -o __INIT__.o __INIT__.s

# Link
if [[ -n $verbose ]]; then
  echo '>' $compiler link -o $out_file_abs *.o
fi
$compiler link -o $out_file_abs *.o


cat *.s > all
echo $out_file
